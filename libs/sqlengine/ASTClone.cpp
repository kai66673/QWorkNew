/**************************************************************************
**
** This file is part of Qt Creator
**
** Copyright (c) 2011 Nokia Corporation and/or its subsidiary(-ies).
**
** Contact: Nokia Corporation (info@qt.nokia.com)
**
**
** GNU Lesser General Public License Usage
**
** This file may be used under the terms of the GNU Lesser General Public
** License version 2.1 as published by the Free Software Foundation and
** appearing in the file LICENSE.LGPL included in the packaging of this file.
** Please review the following information to ensure the GNU Lesser General
** Public License version 2.1 requirements will be met:
** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain additional
** rights. These rights are described in the Nokia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** Other Usage
**
** Alternatively, this file may be used in accordance with the terms and
** conditions contained in a signed written agreement between you and Nokia.
**
** If you have questions regarding the use of this file, please contact
** Nokia at qt-info@nokia.com.
**
**************************************************************************/

//
//  W A R N I N G
//  -------------
//
// This file is automatically generated.
// Changes will be lost.
//

#include "AST.h"
#include "MemoryPool.h"

using namespace Sql;

TranslationUnitAST *TranslationUnitAST::clone(Utils::MemoryPool *pool) const
{
    TranslationUnitAST *ast = new (pool) TranslationUnitAST;
    for (StatementListAST *iter = statement_list, **ast_iter = &ast->statement_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) StatementListAST((iter->value) ? iter->value->clone(pool) : 0);
    return ast;
}

SelectStatementAST *SelectStatementAST::clone(Utils::MemoryPool *pool) const
{
    SelectStatementAST *ast = new (pool) SelectStatementAST;
    for (SelectCoreListAST *iter = select_core_list, **ast_iter = &ast->select_core_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) SelectCoreListAST((iter->value) ? iter->value->clone(pool) : 0);
    for (SelectCompoundListAST *iter = select_compound_list, **ast_iter = &ast->select_compound_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) SelectCompoundListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->order_by_block = order_by_block->clone(pool);
    ast->limit_to_block = limit_to_block->clone(pool);
    ast->last_token = last_token;
    return ast;
}

SelectCoreAST *SelectCoreAST::clone(Utils::MemoryPool *pool) const
{
    SelectCoreAST *ast = new (pool) SelectCoreAST;
    ast->select_token = select_token;
    ast->select_spec_token = select_spec_token;
    for (ResultColumnListAST *iter = columnList, **ast_iter = &ast->columnList;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) ResultColumnListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->from_token = from_token;
    if ( joinSource )
        ast->joinSource = joinSource->clone(pool);
    ast->where_token = where_token;
    if ( whereExpr )
        ast->whereExpr = whereExpr->clone(pool);
    if ( groupBy )
        ast->groupBy = groupBy->clone(pool);
    return ast;
}

InvalidStatementAST *InvalidStatementAST::clone(Utils::MemoryPool *pool) const
{
    InvalidStatementAST *ast = new (pool) InvalidStatementAST(first_token, isSelect);
    return ast;
}

UnknownStatementAST *UnknownStatementAST::clone(Utils::MemoryPool *pool) const
{
    UnknownStatementAST *ast = new (pool) UnknownStatementAST;
    ast->first_token = first_token;
    ast->last_token = last_token;
    return ast;
}

SelectCompoundUnionAST *SelectCompoundUnionAST::clone(Utils::MemoryPool *pool) const
{
    SelectCompoundUnionAST *ast = new (pool) SelectCompoundUnionAST;
    ast->union_token = union_token;
    ast->union_spec_token = union_spec_token;
    return ast;
}

SelectCompoundIntersectAST *SelectCompoundIntersectAST::clone(Utils::MemoryPool *pool) const
{
    SelectCompoundIntersectAST *ast = new (pool) SelectCompoundIntersectAST;
    ast->intersect_token = intersect_token;
    return ast;
}

SelectCompoundExceptAST *SelectCompoundExceptAST::clone(Utils::MemoryPool *pool) const
{
    SelectCompoundExceptAST *ast = new (pool) SelectCompoundExceptAST;
    ast->except_token = except_token;
    return ast;
}

SelectCompoundMinusAST *SelectCompoundMinusAST::clone(Utils::MemoryPool *pool) const
{
    SelectCompoundMinusAST *ast = new (pool) SelectCompoundMinusAST;
    ast->minus_token = minus_token;
    return ast;
}

OrderByBlockAST *OrderByBlockAST::clone(Utils::MemoryPool *pool) const
{
    OrderByBlockAST *ast = new (pool) OrderByBlockAST;
    ast->order_token = order_token;
    ast->by_token = by_token;
    for (OrderingTermListAST *iter = term_list, **ast_iter = &ast->term_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) OrderingTermListAST((iter->value) ? iter->value->clone(pool) : 0);
    return ast;
}

LimitToBlockAST *LimitToBlockAST::clone(Utils::MemoryPool *pool) const
{
    LimitToBlockAST *ast = new (pool) LimitToBlockAST;
    ast->limit_token = limit_token;
    ast->to_token = to_token;
    if ( expr )
        ast->expr = expr->clone(pool);
    ast->row_token = row_token;
    return ast;
}

OrderingTermAST *OrderingTermAST::clone(Utils::MemoryPool *pool) const
{
    OrderingTermAST *ast = new (pool) OrderingTermAST;
    if ( expr )
        ast->expr = expr->clone(pool);
    ast->asc_or_desc_token = asc_or_desc_token;
    return ast;
}

SchemaNameAST *SchemaNameAST::clone(Utils::MemoryPool *pool) const
{
    SchemaNameAST *ast = new (pool) SchemaNameAST;
    ast->name_token = name_token;
    ast->name = name;
    return ast;
}

TableNameAST *TableNameAST::clone(Utils::MemoryPool *pool) const
{
    TableNameAST *ast = new (pool) TableNameAST;
    ast->name_token = name_token;
    ast->name = name;
    return ast;
}

ViewNameAST *ViewNameAST::clone(Utils::MemoryPool *pool) const
{
    ViewNameAST *ast = new (pool) ViewNameAST;
    ast->name_token = name_token;
    ast->name = name;
    return ast;
}

IndexNameAST *IndexNameAST::clone(Utils::MemoryPool *pool) const
{
    IndexNameAST *ast = new (pool) IndexNameAST;
    ast->name_token = name_token;
    ast->name = name;
    return ast;
}

TriggerNameAST *TriggerNameAST::clone(Utils::MemoryPool *pool) const
{
    TriggerNameAST *ast = new (pool) TriggerNameAST;
    ast->name_token = name_token;
    ast->name = name;
    return ast;
}

ConstraintNameAST *ConstraintNameAST::clone(Utils::MemoryPool *pool) const
{
    ConstraintNameAST *ast = new (pool) ConstraintNameAST;
    ast->name_token = name_token;
    ast->name = name;
    return ast;
}

SchemaTableNameAST *SchemaTableNameAST::clone(Utils::MemoryPool *pool) const
{
    SchemaTableNameAST *ast = new (pool) SchemaTableNameAST;
    ast->schemaName = (schemaName ? schemaName->clone(pool) : 0);
    ast->dot_token = dot_token;
    ast->tableName = (tableName ? tableName->clone(pool) : 0);
    return ast;
}

SchemaIndexNameAST *SchemaIndexNameAST::clone(Utils::MemoryPool *pool) const
{
    SchemaIndexNameAST *ast = new (pool) SchemaIndexNameAST;
    ast->schemaName = (schemaName ? schemaName->clone(pool) : 0);
    ast->dot_token = dot_token;
    ast->indexName = (indexName ? indexName->clone(pool) : 0);
    return ast;
}

SchemaTriggerNameAST *SchemaTriggerNameAST::clone(Utils::MemoryPool *pool) const
{
    SchemaTriggerNameAST *ast = new (pool) SchemaTriggerNameAST;
    ast->schemaName = (schemaName ? schemaName->clone(pool) : 0);
    ast->dot_token = dot_token;
    ast->triggerName = (triggerName ? triggerName->clone(pool) : 0);
    return ast;
}

TableAliasAST *TableAliasAST::clone(Utils::MemoryPool *pool) const
{
    TableAliasAST *ast = new (pool) TableAliasAST;
    ast->name_token = name_token;
    ast->name = name;
    return ast;
}

ColumnNameAST *ColumnNameAST::clone(Utils::MemoryPool *pool) const
{
    ColumnNameAST *ast = new (pool) ColumnNameAST;
    if ( schemaName )
        ast->schemaName = schemaName->clone(pool);
    if ( tableOfColumn )
        ast->tableOfColumn = tableOfColumn->clone(pool);
    ast->name_token = name_token;
    ast->name = name;
    return ast;
}

ParamNameAST *ParamNameAST::clone(Utils::MemoryPool *pool) const
{
    ParamNameAST *ast = new (pool) ParamNameAST;
    ast->param_prefix_token = param_prefix_token;
    ast->name_token = name_token;
    ast->name = name;
    return ast;
}

LabelNameAST *LabelNameAST::clone(Utils::MemoryPool *pool) const
{
    LabelNameAST *ast = new (pool) LabelNameAST;
    ast->name_token = name_token;
    ast->name = name;
    return ast;
}

ColumnAliasAST *ColumnAliasAST::clone(Utils::MemoryPool *pool) const
{
    ColumnAliasAST *ast = new (pool) ColumnAliasAST;
    ast->name_token = name_token;
    ast->name = name;
    return ast;
}

FunctionNameAST *FunctionNameAST::clone(Utils::MemoryPool *pool) const
{
    FunctionNameAST *ast = new (pool) FunctionNameAST;
    ast->name_token = name_token;
    ast->name = name;
    return ast;
}

StarResultColumnAST *StarResultColumnAST::clone(Utils::MemoryPool *pool) const
{
    StarResultColumnAST *ast = new (pool) StarResultColumnAST;
    ast->schemaTableName = (schemaTableName ? schemaTableName->clone(pool) : 0);
    ast->dot_token = dot_token;
    ast->star_token = star_token;
    return ast;
}

ExprResultColumnAST *ExprResultColumnAST::clone(Utils::MemoryPool *pool) const
{
    ExprResultColumnAST *ast = new (pool) ExprResultColumnAST;
    if ( expr )
        ast->expr = expr->clone(pool);
    ast->as_token = as_token;
    ast->columnAlias = columnAlias->clone(pool);
    return ast;
}

SubQueryAST *SubQueryAST::clone(Utils::MemoryPool *pool) const
{
    SubQueryAST *ast = new (pool) SubQueryAST;
    ast->lparen_token = lparen_token;
    if ( selectStatement )
        ast->selectStatement = selectStatement->clone(pool);
    ast->rparen_token = rparen_token;
    return ast;
}

DirectSingleSourceAST *DirectSingleSourceAST::clone(Utils::MemoryPool *pool) const
{
    DirectSingleSourceAST *ast = new (pool) DirectSingleSourceAST;
    if ( schemaTableName )
        ast->schemaTableName = schemaTableName->clone(pool);
    ast->as_token = as_token;
    if ( tableAlias )
        ast->tableAlias = tableAlias->clone(pool);
    return ast;
}

SubQuerySingleSourceAST *SubQuerySingleSourceAST::clone(Utils::MemoryPool *pool) const
{
    SubQuerySingleSourceAST *ast = new (pool) SubQuerySingleSourceAST;
    if ( subQuery )
        ast->subQuery = subQuery->clone(pool);
    ast->as_token = as_token;
    if ( tableAlias )
        ast->tableAlias = tableAlias->clone(pool);
    return ast;
}

JoinOpAST *JoinOpAST::clone(Utils::MemoryPool *pool) const
{
    JoinOpAST *ast = new (pool) JoinOpAST;
    ast->first_token = first_token;
    ast->last_token = last_token;
    return ast;
}

JoinConstraintAST *JoinConstraintAST::clone(Utils::MemoryPool *pool) const
{
    JoinConstraintAST *ast = new (pool) JoinConstraintAST;
    ast->on_token = on_token;
    if ( expr )
        ast->expr = expr->clone(pool);
    return ast;
}

JoinItemAST *JoinItemAST::clone(Utils::MemoryPool *pool) const
{
    JoinItemAST *ast = new (pool) JoinItemAST;
    if ( joinOp )
        ast->joinOp = joinOp->clone(pool);
    if ( singleSource )
        ast->singleSource = singleSource->clone(pool);
    if ( joinConstraint )
        ast->joinConstraint = joinConstraint->clone(pool);
    return ast;
}

JoinSourceAST *JoinSourceAST::clone(Utils::MemoryPool *pool) const
{
    JoinSourceAST *ast = new (pool) JoinSourceAST;
    if ( firstSource )
        ast->firstSource = firstSource->clone(pool);
    for (JoinItemListAST *iter = source_list, **ast_iter = &ast->source_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) JoinItemListAST((iter->value) ? iter->value->clone(pool) : 0);
    return ast;
}

GroupByBlockAST *GroupByBlockAST::clone(Utils::MemoryPool *pool) const
{
    GroupByBlockAST *ast = new (pool) GroupByBlockAST;
    ast->group_token = group_token;
    ast->by_token = by_token;
    for (ValueExpressionListAST *iter = group_items_list, **ast_iter = &ast->group_items_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) ValueExpressionListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->having_token = having_token;
    if ( havingExpr )
        ast->havingExpr = havingExpr->clone(pool);
    return ast;
}

DeleteStatementAST *DeleteStatementAST::clone(Utils::MemoryPool *pool) const
{
    DeleteStatementAST *ast = new (pool) DeleteStatementAST;
    ast->delete_token = delete_token;
    ast->from_token = from_token;
    if ( source )
        ast->source = source->clone(pool);
    ast->where_token = where_token;
    if ( whereExpr )
        ast->whereExpr = whereExpr->clone(pool);
    return ast;
}

InsertStatementAST *InsertStatementAST::clone(Utils::MemoryPool *pool) const
{
    InsertStatementAST *ast = new (pool) InsertStatementAST;
    ast->insert_token = insert_token;
    ast->into_token = into_token;
    if ( source )
        ast->source = source->clone(pool);
    ast->lparen_columns_token = lparen_columns_token;
    for (ColumnNameListAST *iter = columns_list, **ast_iter = &ast->columns_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) ColumnNameListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->rparen_columns_token = rparen_columns_token;
    if ( insClause )
        ast->insClause = insClause->clone(pool);
    return ast;
}

UpdateStatementAST *UpdateStatementAST::clone(Utils::MemoryPool *pool) const
{
    UpdateStatementAST *ast = new (pool) UpdateStatementAST;
    ast->update_token = update_token;
    if ( source )
        ast->source = source->clone(pool);
    ast->set_token = set_token;
    for (AssignmentExpressionListAST *iter = upd_list, **ast_iter = &ast->upd_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) AssignmentExpressionListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->where_token = where_token;
    if ( whereExpr )
        ast->whereExpr = whereExpr->clone(pool);
    return ast;
}

CreateTableDirectClauseAST *CreateTableDirectClauseAST::clone(Utils::MemoryPool *pool) const
{
    CreateTableDirectClauseAST *ast = new (pool) CreateTableDirectClauseAST;
    ast->lparen_token = lparen_token;
    for (ColumnDefinitionListAST *iter = column_def_list, ** ast_iter = &ast->column_def_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) ColumnDefinitionListAST((iter->value) ? iter->value->clone(pool) : 0);
    for (TableConstraintListAST *iter = constraintList, ** ast_iter = &ast->constraintList;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) TableConstraintListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->rparen_token = rparen_token;
    return ast;
}

CreateTableAsSelectClauseAST *CreateTableAsSelectClauseAST::clone(Utils::MemoryPool *pool) const
{
    CreateTableAsSelectClauseAST *ast = new (pool) CreateTableAsSelectClauseAST;
    ast->as_token = as_token;
    if ( selectStatement )
        ast->selectStatement = selectStatement->clone(pool);
    return ast;
}

CreateTriggerRefClauseAST *CreateTriggerRefClauseAST::clone(Utils::MemoryPool *pool) const
{
    CreateTriggerRefClauseAST *ast = new (pool) CreateTriggerRefClauseAST(schemaTableName);
    ast->referencing_token = referencing_token;
    ast->new_token = new_token;
    ast->asn_token = asn_token;
    if ( newAlias )
        ast->newAlias = newAlias->clone(pool);
    ast->old_token = old_token;
    ast->aso_token = aso_token;
    if ( oldAlias )
        ast->oldAlias = oldAlias->clone(pool);
    return ast;
}

CreateRdbTriggerBodyAST *CreateRdbTriggerBodyAST::clone(Utils::MemoryPool *pool) const
{
    CreateRdbTriggerBodyAST *ast = new (pool) CreateRdbTriggerBodyAST;
    for (CreateRdbTriggerBodyListAST *iter = item_list, **ast_iter = &ast->item_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) CreateRdbTriggerBodyListAST((iter->value) ? iter->value->clone(pool) : 0);
    return ast;
}

CreateRdbTriggerBodyItemAST *CreateRdbTriggerBodyItemAST::clone(Utils::MemoryPool *pool) const
{
    CreateRdbTriggerBodyItemAST *ast = new (pool) CreateRdbTriggerBodyItemAST;
    ast->when_token = when_token;
    ast->lparen_when_token = lparen_when_token;
    if ( whenExpr )
        ast->whenExpr = whenExpr->clone(pool);
    ast->rparen_when_token = rparen_when_token;
    ast->lparen_token = lparen_token;
    for (StatementListAST *iter = stat_list, ** ast_iter = &ast->stat_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) StatementListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->rparen_token = rparen_token;
    ast->for_token = for_token;
    ast->each_token = each_token;
    ast->row_or_statement_token = row_or_statement_token;
    return ast;
}

ColumnDefinitionAST *ColumnDefinitionAST::clone(Utils::MemoryPool *pool) const
{
    ColumnDefinitionAST *ast = new (pool) ColumnDefinitionAST;
    if ( columnName )
        ast->columnName = columnName->clone(pool);
    if ( columnType )
        ast->columnType = columnType->clone(pool);
    ast->default_token = default_token;
    if ( defaultExpr )
        ast->defaultExpr = defaultExpr->clone(pool);
    for (ColumnConstraintListAST *iter = constraintList, **ast_iter = &ast->constraintList;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) ColumnConstraintListAST((iter->value) ? iter->value->clone(pool) : 0);
    return ast;
}

UniqueOrPkTableConstraintAST *UniqueOrPkTableConstraintAST::clone(Utils::MemoryPool *pool) const
{
    UniqueOrPkTableConstraintAST *ast = new (pool) UniqueOrPkTableConstraintAST;
    ast->constraint_token = constraint_token;
    if ( constraintName )
        ast->constraintName = constraintName->clone(pool);
    ast->unique_or_primary_token = unique_or_primary_token;
    ast->key_token = key_token;
    ast->lparen_token = lparen_token;
    for (SortedColumnNameListAST *iter = column_list, **ast_iter = &ast->column_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) SortedColumnNameListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->rparen_token = rparen_token;
    return ast;
}

CheckTableConstraintAST *CheckTableConstraintAST::clone(Utils::MemoryPool *pool) const
{
    CheckTableConstraintAST *ast = new (pool) CheckTableConstraintAST;
    ast->constraint_token = constraint_token;
    if ( constraintName )
        ast->constraintName = constraintName->clone(pool);
    ast->check_token = check_token;
    ast->lparen_token = lparen_token;
    if ( checkExpr )
        ast->checkExpr = checkExpr->clone(pool);
    ast->rparen_token = rparen_token;
    return ast;
}

FkTableConstraintAST *FkTableConstraintAST::clone(Utils::MemoryPool *pool) const
{
    FkTableConstraintAST *ast = new (pool) FkTableConstraintAST;
    ast->constraint_token = constraint_token;
    if ( constraintName )
        ast->constraintName = constraintName->clone(pool);
    ast->foreign_token = foreign_token;
    ast->key_token = key_token;
    ast->lparen_token = lparen_token;
    for (ColumnNameListAST *iter = col_list, **ast_iter = &ast->col_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) ColumnNameListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->rparen_token = rparen_token;
    if ( refClause )
        ast->refClause = refClause->clone(pool);
    return ast;
}

FkReferencesClauseAST *FkReferencesClauseAST::clone(Utils::MemoryPool *pool) const
{
    FkReferencesClauseAST *ast = new (pool) FkReferencesClauseAST;
    ast->references_token = references_token;
    if ( refSchemaTableName )
        ast->refSchemaTableName = refSchemaTableName->clone(pool);
    ast->ref_lparen_token = ref_lparen_token;
    for (ColumnNameListAST *iter = ref_col_list, **ast_iter = &ast->ref_col_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) ColumnNameListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->ref_rparen_token = ref_rparen_token;
    return ast;
}

PkColumnConstraintAST *PkColumnConstraintAST::clone(Utils::MemoryPool *pool) const
{
    PkColumnConstraintAST *ast = new (pool) PkColumnConstraintAST;
    ast->constraint_token = constraint_token;
    if ( constraintName )
        ast->constraintName = constraintName->clone(pool);
    ast->primary_token = primary_token;
    ast->key_token = key_token;
    ast->asc_or_desc_token = asc_or_desc_token;
    return ast;
}

NotNullColumnConstraintAST *NotNullColumnConstraintAST::clone(Utils::MemoryPool *pool) const
{
    NotNullColumnConstraintAST *ast = new (pool) NotNullColumnConstraintAST;
    ast->constraint_token = constraint_token;
    if ( constraintName )
        ast->constraintName = constraintName->clone(pool);
    ast->not_token = not_token;
    ast->null_token = null_token;
    return ast;
}

UniqueColumnConstraintAST *UniqueColumnConstraintAST::clone(Utils::MemoryPool *pool) const
{
    UniqueColumnConstraintAST *ast = new (pool) UniqueColumnConstraintAST;
    ast->constraint_token = constraint_token;
    if ( constraintName )
        ast->constraintName = constraintName->clone(pool);
    ast->unique_token = unique_token;
    return ast;
}

CheckColumnConstraintAST *CheckColumnConstraintAST::clone(Utils::MemoryPool *pool) const
{
    CheckColumnConstraintAST *ast = new (pool) CheckColumnConstraintAST;
    ast->constraint_token = constraint_token;
    if ( constraintName )
        ast->constraintName = constraintName->clone(pool);
    ast->check_token = check_token;
    ast->lparen_token = lparen_token;
    if ( checkExpr )
        ast->checkExpr = checkExpr->clone(pool);
    ast->rparen_token = rparen_token;
    return ast;
}

ReferencesColumnConstraintAST *ReferencesColumnConstraintAST::clone(Utils::MemoryPool *pool) const
{
    ReferencesColumnConstraintAST *ast = new (pool) ReferencesColumnConstraintAST;
    if ( refClause )
        ast->refClause = refClause->clone(pool);
    return ast;
}

SortedColumnNameAST *SortedColumnNameAST::clone(Utils::MemoryPool *pool) const
{
    SortedColumnNameAST *ast = new (pool) SortedColumnNameAST;
    if ( columnName )
        ast->columnName = columnName->clone(pool);
    ast->asc_or_desc_token = asc_or_desc_token;
    return ast;
}

InsertClauseAsValuesAST *InsertClauseAsValuesAST::clone(Utils::MemoryPool *pool) const
{
    InsertClauseAsValuesAST *ast = new (pool) InsertClauseAsValuesAST;
    ast->values_token = values_token;
    ast->lparen_token = lparen_token;
    for (ValueExpressionListAST *iter = val_list, **ast_iter = &ast->val_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) ValueExpressionListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->rparen_token = rparen_token;
    return ast;
}

InsertClauseAsSelectAST *InsertClauseAsSelectAST::clone(Utils::MemoryPool *pool) const
{
    InsertClauseAsSelectAST *ast = new (pool) InsertClauseAsSelectAST;
    if ( selectStatement )
        ast->selectStatement = selectStatement->clone(pool);
    return ast;
}

CreateTableStatementAST *CreateTableStatementAST::clone(Utils::MemoryPool *pool) const
{
    CreateTableStatementAST *ast = new (pool) CreateTableStatementAST;
    ast->create_token = create_token;
    ast->table_token = table_token;
    if ( schemaTableName )
        ast->schemaTableName = schemaTableName->clone(pool);
    if ( tableClause )
        ast->tableClause = tableClause->clone(pool);
    return ast;
}

CreateViewStatementAST *CreateViewStatementAST::clone(Utils::MemoryPool *pool) const
{
    CreateViewStatementAST *ast = new (pool) CreateViewStatementAST;
    ast->create_token = create_token;
    ast->view_token = view_token;
    if ( schemaViewName )
        ast->schemaViewName = schemaViewName->clone(pool);
    ast->as_token = as_token;
    if ( selectStatement )
        ast->selectStatement = selectStatement->clone(pool);
    return ast;
}

CreateIndexStatementAST *CreateIndexStatementAST::clone(Utils::MemoryPool *pool) const
{
    CreateIndexStatementAST *ast = new (pool) CreateIndexStatementAST;
    ast->create_token = create_token;
    ast->unique_token = unique_token;
    ast->index_token = index_token;
    if ( schemaIndexName )
        ast->schemaIndexName = schemaIndexName->clone(pool);
    ast->on_token = on_token;
    if ( schemaTableName )
        ast->schemaTableName = schemaTableName->clone(pool);
    ast->lparen_token = lparen_token;
    for (SortedColumnNameListAST *iter = columns_list, **ast_iter = &ast->columns_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) SortedColumnNameListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->rparen_token = rparen_token;
    return ast;
}

CreateTriggerStatementAST *CreateTriggerStatementAST::clone(Utils::MemoryPool *pool) const
{
    CreateTriggerStatementAST *ast = new (pool) CreateTriggerStatementAST;
    ast->create_token = create_token;
    ast->trigger_token = trigger_token;
    if ( schemaTriggerName )
        ast->schemaTriggerName = schemaTriggerName->clone(pool);
    ast->before_or_after_token = before_or_after_token;
    ast->action_token = action_token;
    ast->of_token = of_token;
    for (ColumnNameListAST *iter = col_list, **ast_iter = &ast->col_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) ColumnNameListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->on_token = on_token;
    if ( schemaTableName )
        ast->schemaTableName = schemaTableName->clone(pool);
    if ( triggerRefClause )
        ast->triggerRefClause = triggerRefClause->clone(pool);
    if ( triggerBody )
        ast->triggerBody = triggerBody->clone(pool);
    return ast;
}

DropTableStatementAST *DropTableStatementAST::clone(Utils::MemoryPool *pool) const
{
    DropTableStatementAST *ast = new (pool) DropTableStatementAST;
    ast->drop_token = drop_token;
    ast->table_token = table_token;
    if ( schemaTableName )
        ast->schemaTableName = schemaTableName->clone(pool);
    return ast;
}

DropViewStatementAST *DropViewStatementAST::clone(Utils::MemoryPool *pool) const
{
    DropViewStatementAST *ast = new (pool) DropViewStatementAST;
    ast->drop_token = drop_token;
    ast->view_token = view_token;
    if ( schemaViewName )
        ast->schemaViewName = schemaViewName->clone(pool);
    return ast;
}

DropIndexStatementAST *DropIndexStatementAST::clone(Utils::MemoryPool *pool) const
{
    DropIndexStatementAST *ast = new (pool) DropIndexStatementAST;
    ast->drop_token = drop_token;
    ast->index_token = index_token;
    if ( schemaIndexName )
        ast->schemaIndexName = schemaIndexName->clone(pool);
    return ast;
}

DropTriggerStatementAST *DropTriggerStatementAST::clone(Utils::MemoryPool *pool) const
{
    DropTriggerStatementAST *ast = new (pool) DropTriggerStatementAST;
    ast->drop_token = drop_token;
    ast->trigger_token = trigger_token;
    if ( schemaTriggerName )
        ast->schemaTriggerName = schemaTriggerName->clone(pool);
    return ast;
}

TruncateStatementAST *TruncateStatementAST::clone(Utils::MemoryPool *pool) const
{
    TruncateStatementAST *ast = new (pool) TruncateStatementAST;
    ast->truncate_token = truncate_token;
    ast->table_token = table_token;
    if ( schemaTableName )
        ast->schemaTableName = schemaTableName->clone(pool);
    return ast;
}

AlterTableStatementAST *AlterTableStatementAST::clone(Utils::MemoryPool *pool) const
{
    AlterTableStatementAST *ast = new (pool) AlterTableStatementAST;
    ast->alter_token = alter_token;
    ast->table_token = table_token;
    if ( schemaTableName )
        ast->schemaTableName = schemaTableName->clone(pool);
    if ( alterTableClause )
        ast->alterTableClause = alterTableClause->clone(pool);
    return ast;
}

AlterTableDropClauseAST *AlterTableDropClauseAST::clone(Utils::MemoryPool *pool) const
{
    AlterTableDropClauseAST *ast = new (pool) AlterTableDropClauseAST;
    ast->drop_token = drop_token;
    ast->drop_object_type_token = drop_object_type_token;
    if ( dropObjectName )
        ast->dropObjectName = dropObjectName->clone(pool);
    return ast;
}

AlterTableAddConstraintClauseAST *AlterTableAddConstraintClauseAST::clone(Utils::MemoryPool *pool) const
{
    AlterTableAddConstraintClauseAST *ast = new (pool) AlterTableAddConstraintClauseAST;
    ast->add_token = add_token;
    if ( constraint )
        ast->constraint = constraint->clone(pool);
    return ast;
}

AlterTableAddColumnClauseAST *AlterTableAddColumnClauseAST::clone(Utils::MemoryPool *pool) const
{
    AlterTableAddColumnClauseAST *ast = new (pool) AlterTableAddColumnClauseAST;
    ast->add_token = add_token;
    ast->column_token = column_token;
    if ( column )
        ast->column = column->clone(pool);
    return ast;
}

CommentOnTableStatementAST *CommentOnTableStatementAST::clone(Utils::MemoryPool *pool) const
{
    CommentOnTableStatementAST *ast = new (pool) CommentOnTableStatementAST;
    ast->comment_token = comment_token;
    ast->on_token = on_token;
    ast->table_token = table_token;
    if ( schemaTableName )
        ast->schemaTableName = schemaTableName->clone(pool);
    ast->is_token = is_token;
    if ( comment )
        ast->comment = comment->clone(pool);
    return ast;
}

CommentOnColumnStatementAST *CommentOnColumnStatementAST::clone(Utils::MemoryPool *pool) const
{
    CommentOnColumnStatementAST *ast = new (pool) CommentOnColumnStatementAST;
    ast->comment_token = comment_token;
    ast->on_token = on_token;
    ast->column_token = column_token;
    if ( schemaTableName )
        ast->schemaTableName = schemaTableName->clone(pool);
    ast->dot_token = dot_token;
    if ( column )
        ast->column = column->clone(pool);
    ast->is_token = is_token;
    if ( comment )
        ast->comment = comment->clone(pool);
    return ast;
}

CommitStatementAST *CommitStatementAST::clone(Utils::MemoryPool *pool) const
{
    CommitStatementAST *ast = new (pool) CommitStatementAST;
    ast->commit_token = commit_token;
    return ast;
}

RollbackStatementAST *RollbackStatementAST::clone(Utils::MemoryPool *pool) const
{
    RollbackStatementAST *ast = new (pool) RollbackStatementAST;
    ast->rollback_token = rollback_token;
    return ast;
}

CallStatementAST *CallStatementAST::clone(Utils::MemoryPool *pool) const
{
    CallStatementAST *ast = new (pool) CallStatementAST;
    ast->call_token = call_token;
    if ( funcName )
        ast->funcName = funcName->clone(pool);
    ast->lparen_token = lparen_token;
    for (ValueExpressionListAST *iter = arg_list, **ast_iter = &ast->arg_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) ValueExpressionListAST((iter->value) ? iter->value->clone(pool) : 0);
    ast->rparen_token = rparen_token;
    return ast;
}

CompoundValueExpressionAST *CompoundValueExpressionAST::clone(Utils::MemoryPool *pool) const
{
    CompoundValueExpressionAST *ast = new (pool) CompoundValueExpressionAST;
    ast->lparen_token = lparen_token;
    if ( valExpr )
        ast->valExpr = valExpr->clone(pool);
    ast->rparen_token = rparen_token;
    return ast;
}

UnaryValueExpressionAST *UnaryValueExpressionAST::clone(Utils::MemoryPool *pool) const
{
    UnaryValueExpressionAST *ast = new (pool) UnaryValueExpressionAST;
    ast->op_token = op_token;
    if ( valExpr )
        ast->valExpr = valExpr->clone(pool);
    return ast;
}

BinaryValueExpressionAST *BinaryValueExpressionAST::clone(Utils::MemoryPool *pool) const
{
    BinaryValueExpressionAST *ast = new (pool) BinaryValueExpressionAST;
    if ( lvExpr )
        ast->lvExpr = lvExpr->clone(pool);
    ast->op_token = op_token;
    if ( rvExpr )
        ast->rvExpr = rvExpr->clone(pool);
    return ast;
}

ColumnExpressionAST *ColumnExpressionAST::clone(Utils::MemoryPool *pool) const
{
    ColumnExpressionAST *ast = new (pool) ColumnExpressionAST;
    if ( column )
        ast->column = column->clone(pool);
    return ast;
}

LiteralExpressionAST *LiteralExpressionAST::clone(Utils::MemoryPool *pool) const
{
    LiteralExpressionAST *ast = new (pool) LiteralExpressionAST;
    ast->liter_token = liter_token;
    return ast;
}

NumericExpressionAST *NumericExpressionAST::clone(Utils::MemoryPool *pool) const
{
    NumericExpressionAST *ast = new (pool) NumericExpressionAST;
    ast->numeric_token = numeric_token;
    return ast;
}

FunctionExpressionAST *FunctionExpressionAST::clone(Utils::MemoryPool *pool) const
{
    FunctionExpressionAST *ast = new (pool) FunctionExpressionAST;
    if ( functionName )
        ast->functionName = functionName->clone(pool);
    ast->lparen_token = lparen_token;
    for (ValueExpressionListAST *iter = arg_list, **ast_iter = &ast->arg_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) ValueExpressionListAST( (iter->value) ? iter->value->clone(pool) : 0 );
    ast->rparen_token = rparen_token;
    return ast;
}

CastFunctionAST *CastFunctionAST::clone(Utils::MemoryPool *pool) const
{
    CastFunctionAST *ast = new (pool) CastFunctionAST;
    ast->cast_token = cast_token;
    ast->lparen_token = lparen_token;
    if ( castExpr )
        ast->castExpr = castExpr->clone(pool);
    ast->as_token = as_token;
    if ( typeSpec )
        ast->typeSpec = typeSpec->clone(pool);
    ast->rparen_token = rparen_token;
    return ast;
}

SubstringFunctionAST *SubstringFunctionAST::clone(Utils::MemoryPool *pool) const
{
    SubstringFunctionAST *ast = new (pool) SubstringFunctionAST;
    ast->substring_token = substring_token;
    ast->lparen_token = lparen_token;
    if ( strExpr )
        ast->strExpr = strExpr->clone(pool);
    ast->from_token = from_token;
    if ( startExpr )
        ast->startExpr = startExpr->clone(pool);
    ast->for_token = for_token;
    if ( lengthExpr )
        ast->lengthExpr = lengthExpr->clone(pool);
    ast->rparen_token = rparen_token;
    return ast;
}

CountFunctionAST *CountFunctionAST::clone(Utils::MemoryPool *pool) const
{
    CountFunctionAST *ast = new (pool) CountFunctionAST;
    ast->count_token = count_token;
    ast->lparen_token = lparen_token;
    ast->distinct_token = distinct_token;
    if ( countExpr )
        ast->countExpr = countExpr->clone(pool);
    ast->rparen_token = rparen_token;
    return ast;
}

ParameterExpressionAST *ParameterExpressionAST::clone(Utils::MemoryPool *pool) const
{
    ParameterExpressionAST *ast = new (pool) ParameterExpressionAST;
    if ( binding )
        ast->binding = binding->clone(pool);
    return ast;
}

NullValueExpressionAST *NullValueExpressionAST::clone(Utils::MemoryPool *pool) const
{
    NullValueExpressionAST *ast = new (pool) NullValueExpressionAST;
    ast->not_token = not_token;
    ast->null_token = null_token;
    return ast;
}

SelectCompoundValueExpressionAST *SelectCompoundValueExpressionAST::clone(Utils::MemoryPool *pool) const
{
    SelectCompoundValueExpressionAST *ast = new (pool) SelectCompoundValueExpressionAST;
    ast->lparen_token = lparen_token;
    if ( query )
        ast->query = query->clone(pool);
    ast->rparen_token = rparen_token;
    return ast;
}

ValueListExpressionAST *ValueListExpressionAST::clone(Utils::MemoryPool *pool) const
{
    ValueListExpressionAST *ast = new (pool) ValueListExpressionAST;
    ast->lparen_token = lparen_token;
    for (ValueExpressionListAST *iter = val_list, **ast_iter = &ast->val_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) ValueExpressionListAST( (iter->value) ? iter->value->clone(pool) : 0 );
    ast->rparen_roken = rparen_roken;
    return ast;
}

SubQueryExpressionAST *SubQueryExpressionAST::clone(Utils::MemoryPool *pool) const
{
    SubQueryExpressionAST *ast = new (pool) SubQueryExpressionAST;
    ast->lparen_token = lparen_token;
    if ( query )
        ast->query = query->clone(pool);
    ast->rparen_roken = rparen_roken;
    return ast;
}

CompoundConditionExpressionAST *CompoundConditionExpressionAST::clone(Utils::MemoryPool *pool) const
{
    CompoundConditionExpressionAST *ast = new (pool) CompoundConditionExpressionAST;
    ast->lparen_token = lparen_token;
    if ( condExpr )
        ast->condExpr = condExpr->clone(pool);
    ast->rparen_token = rparen_token;
    return ast;
}

InConditionExpressionAST *InConditionExpressionAST::clone(Utils::MemoryPool *pool) const
{
    InConditionExpressionAST *ast = new (pool) InConditionExpressionAST;
    if ( lvExpr )
        ast->lvExpr = lvExpr->clone(pool);
    ast->not_token = not_token;
    ast->in_token = in_token;
    if ( rvExpr )
        ast->rvExpr = rvExpr->clone(pool);
    return ast;
}

LikeConditionExpressionAST *LikeConditionExpressionAST::clone(Utils::MemoryPool *pool) const
{
    LikeConditionExpressionAST *ast = new (pool) LikeConditionExpressionAST;
    if ( lvExpr )
        ast->lvExpr = lvExpr->clone(pool);
    ast->not_token = not_token;
    ast->like_token = like_token;
    if ( rvExpr )
        ast->rvExpr = rvExpr->clone(pool);
    return ast;
}

ExistsConditionExpressionAST *ExistsConditionExpressionAST::clone(Utils::MemoryPool *pool) const
{
    ExistsConditionExpressionAST *ast = new (pool) ExistsConditionExpressionAST;
    ast->not_token = not_token;
    ast->exists_token = exists_token;
    if ( rvExpr )
        ast->rvExpr = rvExpr->clone(pool);
    return ast;
}

BetweenConditionExpressionAST *BetweenConditionExpressionAST::clone(Utils::MemoryPool *pool) const
{
    BetweenConditionExpressionAST *ast = new (pool) BetweenConditionExpressionAST;
    if ( lvExpr )
        ast->lvExpr = lvExpr->clone(pool);
    ast->not_token = not_token;
    ast->between_token = between_token;
    if ( rv1Expr )
        ast->rv1Expr = rv1Expr->clone(pool);
    ast->and_token = and_token;
    if ( rv2Expr )
        ast->rv2Expr = rv2Expr->clone(pool);
    return ast;
}

UnaryConditionExpressionAST *UnaryConditionExpressionAST::clone(Utils::MemoryPool *pool) const
{
    UnaryConditionExpressionAST *ast = new (pool) UnaryConditionExpressionAST;
    if ( lvExpr )
        ast->lvExpr = lvExpr->clone(pool);
    ast->last_op_token = last_op_token;
    return ast;
}

BinaryConditionExpressionAST *BinaryConditionExpressionAST::clone(Utils::MemoryPool *pool) const
{
    BinaryConditionExpressionAST *ast = new (pool) BinaryConditionExpressionAST;
    if ( lvCondExpr )
        ast->lvCondExpr = lvCondExpr->clone(pool);
    ast->cond_op_token = cond_op_token;
    if ( rvCondExpr )
        ast->rvCondExpr = rvCondExpr->clone(pool);
    return ast;
}

AssignmentExpressionAST *AssignmentExpressionAST::clone(Utils::MemoryPool *pool) const
{
    AssignmentExpressionAST *ast = new (pool) AssignmentExpressionAST;
    if ( columnName )
        ast->columnName = columnName->clone(pool);
    ast->equal_token = equal_token;
    if ( rvExpr )
        ast->rvExpr = rvExpr->clone(pool);
    return ast;
}

CaseExpressionAST *CaseExpressionAST::clone(Utils::MemoryPool *pool) const
{
    CaseExpressionAST *ast = new (pool) CaseExpressionAST;
    ast->case_token = case_token;
    if ( caseExpr )
        ast->caseExpr = caseExpr->clone(pool);
    for (CaseExpressionClauseListAST *iter = var_list, **ast_iter = &ast->var_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) CaseExpressionClauseListAST( (iter->value) ? iter->value->clone(pool) : 0 );
    ast->else_token = else_token;
    if ( elseExpr )
        ast->elseExpr = elseExpr->clone(pool);
    ast->end_token = end_token;
    return ast;
}

CaseExpressionClauseAST *CaseExpressionClauseAST::clone(Utils::MemoryPool *pool) const
{
    CaseExpressionClauseAST *ast = new (pool) CaseExpressionClauseAST;
    ast->when_token = when_token;
    if ( whenExpr )
        ast->whenExpr = whenExpr->clone(pool);
    ast->then_token = then_token;
    if ( thenExpr )
        ast->thenExpr = thenExpr->clone(pool);
    return ast;
}

CaseConditionAST *CaseConditionAST::clone(Utils::MemoryPool *pool) const
{
    CaseConditionAST *ast = new (pool) CaseConditionAST;
    ast->case_token = case_token;
    for (CaseConditionClauseListAST *iter = var_list, **ast_iter = &ast->var_list;
         iter; iter = iter->next, ast_iter = &(*ast_iter)->next)
        *ast_iter = new (pool) CaseConditionClauseListAST( (iter->value) ? iter->value->clone(pool) : 0 );
    ast->else_token = else_token;
    if ( elseExpr )
        ast->elseExpr = elseExpr->clone(pool);
    ast->end_token = end_token;
    return ast;
}

CaseConditionClauseAST *CaseConditionClauseAST::clone(Utils::MemoryPool *pool) const
{
    CaseConditionClauseAST *ast = new (pool) CaseConditionClauseAST;
    ast->when_token = when_token;
    if ( whenExpr )
        ast->whenExpr = whenExpr->clone(pool);
    ast->then_token = then_token;
    if ( thenExpr )
        ast->thenExpr = thenExpr->clone(pool);
    return ast;
}

CharacterTypeAST *CharacterTypeAST::clone(Utils::MemoryPool *pool) const
{
    CharacterTypeAST *ast = new (pool) CharacterTypeAST;
    ast->type_token = type_token;
    ast->lparen_token = lparen_token;
    ast->size_token = size_token;
    ast->rparen_token = rparen_token;
    return ast;
}

NumberTypeAST *NumberTypeAST::clone(Utils::MemoryPool *pool) const
{
    NumberTypeAST *ast = new (pool) NumberTypeAST;
    ast->type_token = type_token;
    ast->lparen_token = lparen_token;
    ast->size_token = size_token;
    ast->comma_token = comma_token;
    ast->prec_token = prec_token;
    ast->rparen_token = rparen_token;
    return ast;
}

SimpleTypeAST *SimpleTypeAST::clone(Utils::MemoryPool *pool) const
{
    SimpleTypeAST *ast = new (pool) SimpleTypeAST;
    ast->type_token = type_token;
    return ast;
}
